// SPDX-License-Identifier: MIXED

// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.3
// License-Identifier: MIT
pragma solidity 0.6.12;

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library BoringMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a + b) >= b, "BoringMath: Add Overflow");
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a - b) <= a, "BoringMath: Underflow");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b == 0 || (c = a * b) / b == a, "BoringMath: Mul Overflow");
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= uint128(-1), "BoringMath: uint128 Overflow");
        c = uint128(a);
    }

    function to64(uint256 a) internal pure returns (uint64 c) {
        require(a <= uint64(-1), "BoringMath: uint64 Overflow");
        c = uint64(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= uint32(-1), "BoringMath: uint32 Overflow");
        c = uint32(a);
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.
library BoringMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a + b) >= b, "BoringMath: Add Overflow");
    }

    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a - b) <= a, "BoringMath: Underflow");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.
library BoringMath64 {
    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a + b) >= b, "BoringMath: Add Overflow");
    }

    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a - b) <= a, "BoringMath: Underflow");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath32 {
    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a + b) >= b, "BoringMath: Add Overflow");
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a - b) <= a, "BoringMath: Underflow");
    }
}

// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.3
// License-Identifier: MIT
pragma solidity 0.6.12;

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice EIP 2612
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.3
// License-Identifier: MIT
pragma solidity 0.6.12;

// solhint-disable avoid-low-level-calls

library BoringERC20 {
    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
    bytes4 private constant SIG_NAME = 0x06fdde03; // name()
    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)
    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)

    function returnDataToString(bytes memory data) internal pure returns (string memory) {
        if (data.length >= 64) {
            return abi.decode(data, (string));
        } else if (data.length == 32) {
            uint8 i = 0;
            while (i < 32 && data[i] != 0) {
                i++;
            }
            bytes memory bytesArray = new bytes(i);
            for (i = 0; i < 32 && data[i] != 0; i++) {
                bytesArray[i] = data[i];
            }
            return string(bytesArray);
        } else {
            return "???";
        }
    }

    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.
    /// @param token The address of the ERC-20 token contract.
    /// @return (string) Token symbol.
    function safeSymbol(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));
        return success ? returnDataToString(data) : "???";
    }

    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.
    /// @param token The address of the ERC-20 token contract.
    /// @return (string) Token name.
    function safeName(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));
        return success ? returnDataToString(data) : "???";
    }

    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.
    /// @param token The address of the ERC-20 token contract.
    /// @return (uint8) Token decimals.
    function safeDecimals(IERC20 token) internal view returns (uint8) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));
        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;
    }

    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.
    /// @param token The address of the ERC-20 token.
    /// @param to The address of the user to check.
    /// @return amount The token amount.
    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));
        require(success && data.length >= 32, "BoringERC20: BalanceOf failed");
        amount = abi.decode(data, (uint256));
    }

    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: Transfer failed");
    }

    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param from Transfer tokens from.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: TransferFrom failed");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol@v1.2.3
// License-Identifier: MIT

//License-Identifier: MIT
pragma solidity ^0.6.12;

// solhint-disable no-inline-assembly

library BoringAddress {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringSingleNFT.sol@v1.2.3
// License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

// solhint-disable avoid-low-level-calls

interface ERC721TokenReceiver {
    function onERC721Received(
        address _operator,
        address _from,
        uint256 _tokenId,
        bytes calldata _data
    ) external returns (bytes4);
}

abstract contract BoringSingleNFT {
    /// This contract is an EIP-721 compliant contract that holds only a single NFT (totalSupply = 1)
    using BoringAddress for address;

    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    // hodler must be set in derived contract
    // Since there is only one NFT, we only track single holder and allowed
    address public hodler;
    address public allowed;
    uint256 public constant totalSupply = 1;

    // operator mappings as per usual
    mapping(address => mapping(address => bool)) public operators;

    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {
        return
            interfaceID == this.supportsInterface.selector || // EIP-165
            interfaceID == 0x80ac58cd; // EIP-721
    }

    function balanceOf(address _owner) public view returns (uint256) {
        require(_owner != address(0), "No zero address");
        return _owner == hodler ? 1 : 0;
    }

    function ownerOf(uint256 _tokenId) public view returns (address) {
        require(_tokenId == 0, "Invalid token ID");
        require(hodler != address(0), "No owner");
        return hodler;
    }

    function approve(address _approved, uint256 _tokenId) public payable {
        require(_tokenId == 0, "Invalid token ID");
        require(msg.sender == hodler || operators[hodler][msg.sender], "Not allowed");
        allowed = _approved;
        emit Approval(msg.sender, _approved, _tokenId);
    }

    function setApprovalForAll(address _operator, bool _approved) public {
        operators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    function getApproved(uint256 _tokenId) public view returns (address) {
        require(_tokenId == 0, "Invalid token ID");
        return allowed;
    }

    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
        return operators[_owner][_operator];
    }

    function _transferBase(address to) internal {
        emit Transfer(hodler, to, 0);
        hodler = to;
        // EIP-721 seems to suggest not to emit the Approval event here as it is indicated by the Transfer event.
        allowed = address(0);
    }

    function _transfer(
        address from,
        address to,
        uint256 _tokenId
    ) internal {
        require(_tokenId == 0, "Invalid token ID");
        require(from == hodler, "From not owner");
        require(msg.sender == hodler || msg.sender == allowed || operators[hodler][msg.sender], "Transfer not allowed");
        require(to != address(0), "No zero address");
        _transferBase(to);
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) public payable {
        _transfer(_from, _to, _tokenId);
    }

    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) public payable {
        safeTransferFrom(_from, _to, _tokenId, "");
    }

    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _tokenId,
        bytes memory _data
    ) public payable {
        _transfer(_from, _to, _tokenId);
        if (_to.isContract()) {
            require(
                ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) ==
                    bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")),
                "Wrong return value"
            );
        }
    }

    function tokenURI(uint256 _tokenId) public pure returns (string memory) {
        require(_tokenId == 0, "Invalid token ID");
        return _tokenURI();
    }

    function _tokenURI() internal pure virtual returns (string memory);
}

// File contracts/Canvas.sol
//License-Identifier: MIT
//  _____ _          _   _____            
// |  __ (_)        | | |_   _|           
// | |__) |__  _____| |   | |  _ __   ___ 
// |  ___/ \ \/ / _ \ |   | | | '_ \ / __|
// | |   | |>  <  __/ |  _| |_| | | | (__ 
// |_|   |_/_/\_\___|_| |_____|_| |_|\___| Canvas
//
// Flung together by BoringCrypto during COVID-19 lockdown in 2021
// Stay safe! 

// Alpha here https://bit.ly/3icxSru

pragma solidity ^0.6.12;



// solhint-disable avoid-low-level-calls

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}

interface Pixel is IERC20 {
    function burn(uint256 amount) external;
}

contract Canvas is BoringSingleNFT {
    using BoringMath for uint256;
    using BoringERC20 for Pixel;

    event Buy(address hodler, address buyer, uint256 price, uint256 hodler_share);

    string public constant name = "The Canvas of Pixel Inc";
    string public constant symbol = "CANVAS";

    uint256 public price;
    Pixel public immutable pixel;
    string public info;

    constructor(Pixel _pixel) public {
        pixel = _pixel;
        price = _pixel.totalSupply() / 200000;
        _transferBase(address(_pixel));
    }

    function _tokenURI() internal override pure returns (string memory) {
        // {"name": "Canvas", "description": "The final canvas created by the Pixel Inc project, 1000x1000 pixels painted by many different collaborators. Be aware, the canvas is always for sale through the website, don't list this on marketplaces! All the image and link data is stored fully on-chain and can be retrieved by querying the contract. The javascript code for this is included in this contract.", "image": "ipfs://bafybeidhigbhrccj27qrgnfswebfcciiywa46y2pisbtlad6vi2h5iu3u4/"}
        return string(abi.encodePacked('data:application/json;base64,eyJuYW1lIjogIkNhbnZhcyIsICJkZXNjcmlwdGlvbiI6ICJUaGUgZmluYWwgY2FudmFzIGNyZWF0ZWQgYnkgdGhlIFBpeGVsIEluYyBwcm9qZWN0LCAxMDAweDEwMDAgcGl4ZWxzIHBhaW50ZWQgYnkgbWFueSBkaWZmZXJlbnQgY29sbGFib3JhdG9ycy4gQmUgYXdhcmUsIHRoZSBjYW52YXMgaXMgYWx3YXlzIGZvciBzYWxlIHRocm91Z2ggdGhlIHdlYnNpdGUsIGRvbid0IGxpc3QgdGhpcyBvbiBtYXJrZXRwbGFjZXMhIEFsbCB0aGUgaW1hZ2UgYW5kIGxpbmsgZGF0YSBpcyBzdG9yZWQgZnVsbHkgb24tY2hhaW4gYW5kIGNhbiBiZSByZXRyaWV2ZWQgYnkgcXVlcnlpbmcgdGhlIGNvbnRyYWN0LiBUaGUgamF2YXNjcmlwdCBjb2RlIGZvciB0aGlzIGlzIGluY2x1ZGVkIGluIHRoaXMgY29udHJhY3QuIiwgImltYWdlIjogImlwZnM6Ly9iYWZ5YmVpZGhpZ2JocmNjajI3cXJnbmZzd2ViZmNjaWl5d2E0NnkycGlzYnRsYWQ2dmkyaDVpdTN1NC8ifQ'));
    }

    function buy() external payable {
        require(msg.value == price, "Value != price");

        // Send original price paid + 10% back to the hodler with max 20.000 gas. If this fails, continue anyway to prevent grieving/blocking attacks.
        uint256 hodler_share = hodler == address(pixel) ? 0 : price.mul(110) / 150;
        bool success;
        (success, ) = hodler.call{value: hodler_share, gas: 20000}("");

        emit Buy(hodler, msg.sender, price, hodler_share);

        price = price.mul(150) / 100; // Increase price by 50%
        _transferBase(msg.sender);
    }

    function redeem(uint256 amount) external {
        uint256 share = address(this).balance.mul(amount) / pixel.totalSupply();
        pixel.safeTransferFrom(msg.sender, address(this), amount);
        pixel.burn(amount);
        bool success;
        (success, ) = msg.sender.call{value: share, gas: 20000}("");
        require(success, "Sending of ETH failed");
    }

    function setInfo(string memory info_) external {
        require(msg.sender == hodler, "Canvas: not hodler");
        info = info_;
    }

    function poll(address user) public view returns(address hodler_, address allowed_, uint256 price_, uint256 pool, uint256 share, string memory info_) {
        return (hodler, allowed, price, address(this).balance, address(this).balance.mul(pixel.balanceOf(user)) / pixel.totalSupply(), info);
    }

    function getCanvasImageCode() public pure returns (string memory code) {
        return "if(process.argv[2]){const e=require('ethers'),t=new e.Contract('0x1590ABe3612Be1CB3ab5B0f28874D521576e97Dc',[{inputs:[{internalType:'uint256[]',name:'blockNumbers',type:'uint256[]'}],name:'getBlocks',outputs:[{components:[{internalType:'address',name:'owner',type:'address'},{internalType:'string',name:'url',type:'string'},{internalType:'string',name:'description',type:'string'},{internalType:'bytes',name:'pixels',type:'bytes'},{internalType:'uint128',name:'lastPrice',type:'uint128'},{internalType:'uint32',name:'number',type:'uint32'}],internalType:'struct PixelV2.ExportBlock[]',name:'blocks',type:'tuple[]'}],stateMutability:'view',type:'function'}],new e.providers.JsonRpcProvider(process.argv[2])),{Canvas:a,Image:b}=require('node-canvas');async function main(){const e=new a(1e3,1e3),n=e.getContext('2d');for(let e=0;e<100;e++){console.log(100*e);let a=await t.getBlocks([...Array(100).keys()].map(t=>t+100*e));for(let t in a){let s=parseInt(a[t].pixels.substr(2,2)),r=a[t].pixels.substr(4);if(s<=4){1==s&&(r='89504e470d0a1a0a0000000d494844520000000a0000000a08060000008d32cfbd0000'+r+'0000000049454e44ae426082'),3==s&&(r='ffd8ffe000104a46494600010100000100010000ffdb0043000a07070807060a0808080b0a0a0b0e18100e0d0d0e1d15161118231f2524221f2221262b372f26293429212230413134393b3e3e3e252e4449433c48373d3e3bffdb0043010a0b0b0e0d0e1c10101c3b2822283b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3bffc0001108000a000a03012200021101031101ffc400'+r+'ffd9');const a=new b;a.src=Buffer.from(r,'hex'),n.drawImage(a,10*t,10*e,10,10)}else if(5==s){let a=n.createImageData(10,10);for(let e=0;e<100;e++){let t=parseInt(r.substr(6*e,6),16);a.data.set([Math.floor(t/65536),Math.floor(t%65536/256),t%256,255],4*e)}n.putImageData(a,10*t,10*e)}else 6!=s&&r||(n.fillStyle='#'+(r||'000000'),n.fillRect(10*t,10*e,10,10))}}const s=e.toBuffer('image/png');require('fs').writeFileSync('canvas.png',s)}main()}else console.log('Usage: node getImage.js <RPC URL>');";
    }
}